<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>스피키 네르지 마세요!</title>
    <style>
        body { 
            margin: 0; 
            background-color: #121212; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            height: 100vh; overflow: hidden; font-family: sans-serif;
            /* 모바일 스크롤/새로고침 방지 */
            touch-action: none;
        }
        #game-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        canvas { 
            background-color: transparent; 
            cursor: pointer; 
            border-radius: 12px; 
            display: block;
            z-index: 1;
        }
        #pumkin-img {
            position: absolute;
            width: 80px;
            height: 80px;
            cursor: grab;
            z-index: 2;
            user-select: none;
            -webkit-user-drag: none;
        }
        .info { 
            color: #999; 
            margin-top: 15px; 
            font-size: 14px; 
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .shake-canvas {
            animation: shake 0.5s infinite;
        }
    </style>
</head>
<body>
    <div id="start-screen" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(18, 18, 18, 0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; cursor: pointer;">
        <h1 style="color: white; margin-bottom: 20px;">스피키 네르지 마세요!</h1>
        <p style="color: #999;">화면을 터치해서 시작하세요!</p>
    </div>

    <div id="game-container">
        <canvas id="canvas"></canvas>
        <img id="pumkin-img" src="Image/pumkin.png" alt="pumkin">
    </div>
    <div class="info">흐에엥! 스피키 네르지 마세요!</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const pumkinEl = document.getElementById('pumkin-img');
    
    const imgSpeakyCrying = 'Image/Speaky_Crying.png';
    const imgSpeakySmile = 'Image/Speaky_Smile.png';
    
    const soundDown = new Audio('Sounds/Speaky1.mp3');
    const soundUp = new Audio('Sounds/Speaky2.mp3');
    const soundIdle = new Audio('Sounds/Speaky3.mp3');
    const soundHappy = new Audio('Sounds/SpeakyHappy.m4a');

    let currentSpeakyImg = new Image();
    let isHappy = false;
    const rows = 40; const cols = 40;
    let mesh = [];
    let originalMesh = [];
    let isMouseDown = false;
    let isDraggingPumkin = false;
    let targetX = 0;
    let fixedY = 20;
    let lastInteractionTime = Date.now();
    let shakeTimer = null;

    let pPos = { x: 0, y: 0, originX: 0, originY: 0 };

    // 좌표 추출 헬퍼 함수
    function getEventPos(e) {
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;
        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    }

    window.onload = function() {
        currentSpeakyImg.src = imgSpeakyCrying;
        currentSpeakyImg.onload = function() {
            canvas.width = currentSpeakyImg.width + 200;
            canvas.height = currentSpeakyImg.height;
            pPos.originX = currentSpeakyImg.width + 100;
            pPos.originY = canvas.height / 1.5;
            updatePumkinStyle(pPos.originX, pPos.originY);
            initMesh();
        };
    };

    function updatePumkinStyle(x, y) {
        pPos.x = x;
        pPos.y = y;
        pumkinEl.style.left = x + "px";
        pumkinEl.style.top = y + "px";
    }

    function initMesh() {
        mesh = [];
        originalMesh = [];
        for (let y = 0; y <= rows; y++) {
            for (let x = 0; x <= cols; x++) {
                const px = (x / cols) * currentSpeakyImg.width;
                const py = (y / rows) * currentSpeakyImg.height;
                mesh.push({x: px, y: py, vx: 0, vy: 0});
                originalMesh.push({x: px, y: py});
            }
        }
    }

    const startScreen = document.getElementById('start-screen');
    const handleStart = () => {
        startScreen.style.display = 'none';
        animate();
    };
    startScreen.addEventListener('click', handleStart);
    startScreen.addEventListener('touchstart', handleStart);

    function stopAllSounds() {
        [soundDown, soundUp, soundIdle, soundHappy].forEach(s => { s.pause(); s.currentTime = 0; });
    }

    function stopShake() {
        canvas.classList.remove('shake-canvas');
        soundIdle.pause();
        soundIdle.currentTime = 0;
        if (shakeTimer) {
            clearTimeout(shakeTimer);
            shakeTimer = null;
        }
    }

    // --- 인터랙션 로직 통합 ---
    const onDown = (e) => {
        const pos = getEventPos(e);
        if (e.target === pumkinEl) {
            isDraggingPumkin = true;
            pumkinEl.style.cursor = 'grabbing';
        } else if (pos.x <= currentSpeakyImg.width) {
            if (isHappy) {
                isHappy = false;
                currentSpeakyImg.src = imgSpeakyCrying;
            }
            isMouseDown = true;
            stopShake();
            stopAllSounds();
            soundDown.play();
        }
        lastInteractionTime = Date.now();
    };

    const onMove = (e) => {
        const pos = getEventPos(e);
        if (isDraggingPumkin) {
            updatePumkinStyle(pos.x - 40, pos.y - 40);
        }
        targetX = pos.x;
    };

    const onUp = () => {
        if (isDraggingPumkin) {
            if (pPos.x < currentSpeakyImg.width) {
                stopShake(); 
                isHappy = true;
                currentSpeakyImg.src = imgSpeakySmile;
                stopAllSounds();
                soundHappy.play();
            }
            updatePumkinStyle(pPos.originX, pPos.originY);
            pumkinEl.style.cursor = 'grab';
        }
        if (isMouseDown && !isHappy) {
            stopAllSounds();
            soundUp.play();
        }
        isMouseDown = false;
        isDraggingPumkin = false;
        lastInteractionTime = Date.now();
    };

    // 마우스 이벤트
    pumkinEl.addEventListener('mousedown', onDown);
    canvas.addEventListener('mousedown', onDown);
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);

    // 터치 이벤트 (모바일 대응)
    pumkinEl.addEventListener('touchstart', (e) => { e.preventDefault(); onDown(e); }, {passive: false});
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onDown(e); }, {passive: false});
    window.addEventListener('touchmove', (e) => { onMove(e); }, {passive: false});
    window.addEventListener('touchend', onUp);

    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const now = Date.now();

        if (now - lastInteractionTime > 5500 && !isMouseDown && !isDraggingPumkin) {
            stopAllSounds();
            soundIdle.play();
            if (isHappy) {
                isHappy = false;
                currentSpeakyImg.src = imgSpeakyCrying;
            }
            canvas.classList.add('shake-canvas');
            shakeTimer = setTimeout(() => { 
                canvas.classList.remove('shake-canvas'); 
                shakeTimer = null;
            }, 2000);
            lastInteractionTime = now;
        }

        const radius = 220;
        const spring = 0.1;
        const friction = 0.45;

        for (let i = 0; i < mesh.length; i++) {
            const p = mesh[i];
            const orig = originalMesh[i];

            if (isMouseDown && !isHappy) {
                const dx = p.x - targetX;
                const dy = p.y - fixedY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < radius) {
                    const force = (radius - dist) / radius;
                    p.vy += force * 0.7 * 20;
                    p.vx += (dx / dist) * force * 5;
                }
            }
            const ax = (orig.x - p.x) * spring;
            const ay = (orig.y - p.y) * spring;
            p.vx = (p.vx + ax) * friction;
            p.vy = (p.vy + ay) * friction;
            p.x += p.vx;
            p.y += p.vy;
        }
        render();
        requestAnimationFrame(animate);
    }

    function render() {
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                drawTriangle(x, y, false);
                drawTriangle(x, y, true);
            }
        }
    }

    function drawTriangle(x, y, reverse) {
        const i1 = y * (cols + 1) + x;
        const i2 = i1 + 1;
        const i3 = (y + 1) * (cols + 1) + x;
        const i4 = i3 + 1;
        let p1, p2, p3, o1, o2, o3;
        if (!reverse) {
            p1 = mesh[i1]; p2 = mesh[i2]; p3 = mesh[i3];
            o1 = originalMesh[i1]; o2 = originalMesh[i2]; o3 = originalMesh[i3];
        } else {
            p1 = mesh[i2]; p2 = mesh[i4]; p3 = mesh[i3];
            o1 = originalMesh[i2]; o2 = originalMesh[i4]; o3 = originalMesh[i3];
        }
        
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x + 7.5, p2.y + 7.5);
        ctx.lineTo(p3.x + 7.5, p3.y + 7.5);
        ctx.closePath();
        ctx.clip();
        
        const dnm = o1.x * (o2.y - o3.y) - o1.y * (o2.x - o3.x) + (o2.x * o3.y - o2.y * o3.x);
        if (Math.abs(dnm) < 0.1) { ctx.restore(); return; }

        const a = (p1.x * (o2.y - o3.y) - o1.y * (p2.x - p3.x) + (p2.x * o3.y - o2.y * p3.x)) / dnm;
        const b = (o1.x * (p2.x - p3.x) - p1.x * (o2.x - o3.x) + (o2.x * p3.x - p2.x * o3.x)) / dnm;
        const c = (o1.x * (o2.y * p3.x - p2.x * o3.y) - o1.y * (o2.x * p3.x - p2.x * o3.x) + p1.x * (o2.x * o3.y - o2.y * o3.x)) / dnm;
        const d = (p1.y * (o2.y - o3.y) - o1.y * (p2.y - p3.y) + (p2.y * o3.y - o2.y * p3.y)) / dnm;
        const e = (o1.x * (p2.y - p3.y) - p1.y * (o2.x - o3.x) + (o2.x * p3.y - p2.y * o3.x)) / dnm;
        const f = (o1.x * (o2.y * p3.y - p2.y * o3.y) - o1.y * (o2.x * p3.y - p2.y * o3.x) + p1.y * (o2.x * o3.y - o2.y * o3.x)) / dnm;
        
        ctx.setTransform(a, d, b, e, c, f);
        ctx.drawImage(currentSpeakyImg, 0, 0);
        ctx.restore();
    }
</script>
</body>
</html>
