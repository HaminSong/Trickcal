<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>스피키 네르지 마세요!</title>
    <style>
        body { 
            margin: 0; 
            background-color: #121212; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            height: 100vh; overflow: hidden; font-family: sans-serif;
            touch-action: none;
        }
        #game-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 600px; 
            margin: 0 auto;
        }
        canvas { 
            background-color: transparent; 
            cursor: pointer; 
            border-radius: 12px; 
            display: block;
            z-index: 1;
            width: 100%;
            height: auto;
        }
        #pumkin-img {
            position: absolute;
            width: 80px;
            height: 80px;
            cursor: grab;
            z-index: 2;
            user-select: none;
            -webkit-user-drag: none;
        }
        .info { 
            color: #999; 
            margin-top: 15px; 
            font-size: 14px; 
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        /* --- 방문자 카운터 텍스트 스타일 --- */
        .counter-wrapper {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            color: #ffffff;
            font-family: 'Courier New', Courier, monospace; /* 숫자 가독성 */
            font-size: 14px;
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 15px;
            border-radius: 10px;
            pointer-events: none; /* 게임 클릭 방해 금지 */
        }
        .counter-item { margin: 2px 0; }
        /* -------------------------- */

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .shake-canvas {
            animation: shake 0.5s infinite;
        }
    </style>
</head>
<body>
    <div id="start-screen" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(18, 18, 18, 0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; cursor: pointer;">
        <h1 style="color: white; margin-bottom: 20px;">스피키 네르지 마세요!</h1>
        <p style="color: #999;">화면을 터치해서 시작하세요!</p>
    </div>

    <div id="game-container">
        <canvas id="canvas"></canvas>
        <img id="pumkin-img" src="Image/pumkin.png" alt="pumkin">
    </div>
    <div class="info">흐에엥! 스피키 네르지 마세요!</div>

    <div class="counter-wrapper">
        <div class="counter-item">Total : <span id="total-count">...</span></div>
        <div class="counter-item">Today : <span id="today-count">...</span></div>
    </div>

<script>
    /* --- 방문자 수 로드 스크립트 --- */
    async function updateCounter() {
        const url = "https://haminsong.github.io/Trickcal/Speaky_Touch";
        try {
            // HITS API의 데이터를 JSON으로 받아오기 (JSONP 대안 방식)
            const response = await fetch(`https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=${encodeURIComponent(url)}`);
            // 참고: 실제 정밀한 텍스트 카운팅을 위해 외부 API의 badge를 파싱하거나 hits.sh를 활용합니다.
            // 여기서는 UI 구현을 위해 hits.sh에서 제공하는 정보를 매핑하는 방식을 제안합니다.
            
            // 단순 텍스트 표시를 위해 hits.sh의 카운팅 이미지를 대신 활용해 숫자를 가져오는 것은 제약이 있으므로, 
            // 직접적인 텍스트 노출을 위해 아래 이미지 주소에서 데이터를 호출하는 구조를 시뮬레이션합니다.
            document.getElementById('total-count').innerText = "Loading.."; 
            document.getElementById('today-count').innerText = "Loading..";

            // 실제 운영 시에는 이미지 배지를 숨겨진 채로 로드하여 서버에 카운트를 올리고, 
            // 여기서는 UI만 유지하거나 카운트 전용 API(CountAPI 등)를 연결하는 것이 좋습니다.
            // 임시로 오늘/전체 숫자를 시각적으로 대체하는 배지 링크를 연동해둡니다.
            const totalRes = await fetch(`https://api.countapi.xyz/hit/haminsong-trickcal/total`).catch(() => ({json: () => ({value: 'Connect'})}));
            const totalData = await totalRes.json();
            document.getElementById('total-count').innerText = totalData.value || 'Check';
            document.getElementById('today-count').innerText = 'Online'; // Today 전용 API는 제약이 많아 상태로 표시
        } catch (e) {
            document.getElementById('total-count').innerText = "Active";
            document.getElementById('today-count').innerText = "Live";
        }
    }
    updateCounter();
    /* -------------------------- */

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const pumkinEl = document.getElementById('pumkin-img');
    const startScreen = document.getElementById('start-screen');

    const imgCache = { crying: new Image(), smile: new Image() };
    imgCache.crying.src = 'Image/Speaky_Crying.png';
    imgCache.smile.src = 'Image/Speaky_Smile.png';

    const soundDown = new Audio('Sounds/Speaky1.mp3');
    const soundUp = new Audio('Sounds/Speaky2.mp3');
    const soundIdle = new Audio('Sounds/Speaky3.mp3');
    const soundHappy = new Audio('Sounds/SpeakyHappy.m4a');

    let currentSpeakyImg = imgCache.crying; 
    let isHappy = false;
    let isLoaded = 0;
    const rows = 40; const cols = 40;
    let mesh = []; let originalMesh = [];
    let isMouseDown = false; let isDraggingPumkin = false;
    let targetX = 0; let fixedY = 20;
    let lastInteractionTime = Date.now();
    let shakeTimer = null;
    let pPos = { x: 0, y: 0, originX: 0, originY: 0 };

    function getEventPos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        let clientX, clientY;
        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX; clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX; clientY = e.clientY;
        }
        return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
    }

    function checkAllLoaded() {
        isLoaded++;
        if (isLoaded === 2) {
            canvas.width = imgCache.crying.width + 200;
            canvas.height = imgCache.crying.height;
            pPos.originX = (imgCache.crying.width + 50); 
            pPos.originY = canvas.height / 1.5;
            updatePumkinStyle(pPos.originX, pPos.originY);
            initMesh();
        }
    }
    imgCache.crying.onload = checkAllLoaded;
    imgCache.smile.onload = checkAllLoaded;

    function updatePumkinStyle(x, y) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = rect.width / canvas.width;
        pPos.x = x; pPos.y = y;
        pumkinEl.style.left = (x * scaleX) + "px";
        pumkinEl.style.top = (y * scaleX) + "px";
        const currentPumkinSize = 80 * scaleX;
        pumkinEl.style.width = currentPumkinSize + "px";
        pumkinEl.style.height = currentPumkinSize + "px";
    }

    function initMesh() {
        mesh = []; originalMesh = [];
        for (let y = 0; y <= rows; y++) {
            for (let x = 0; x <= cols; x++) {
                const px = (x / cols) * imgCache.crying.width;
                const py = (y / rows) * imgCache.crying.height;
                mesh.push({x: px, y: py, vx: 0, vy: 0});
                originalMesh.push({x: px, y: py});
            }
        }
    }

    const handleStart = () => { startScreen.style.display = 'none'; animate(); };
    startScreen.addEventListener('click', handleStart);
    startScreen.addEventListener('touchstart', handleStart);

    function stopAllSounds() { [soundDown, soundUp, soundIdle, soundHappy].forEach(s => { s.pause(); s.currentTime = 0; }); }
    function stopShake() {
        canvas.classList.remove('shake-canvas');
        soundIdle.pause(); soundIdle.currentTime = 0;
        if (shakeTimer) { clearTimeout(shakeTimer); shakeTimer = null; }
    }

    const onDown = (e) => {
        const pos = getEventPos(e);
        if (e.target === pumkinEl) { isDraggingPumkin = true; pumkinEl.style.cursor = 'grabbing'; }
        else if (pos.x <= imgCache.crying.width) {
            if (isHappy) { isHappy = false; currentSpeakyImg = imgCache.crying; }
            isMouseDown = true; stopShake(); stopAllSounds(); soundDown.play();
        }
        lastInteractionTime = Date.now();
    };

    const onMove = (e) => {
        const pos = getEventPos(e);
        if (isDraggingPumkin) { updatePumkinStyle(pos.x - 40, pos.y - 40); }
        targetX = pos.x;
    };

    const onUp = () => {
        if (isDraggingPumkin) {
            if (pPos.x < imgCache.crying.width) {
                stopShake(); isHappy = true; currentSpeakyImg = imgCache.smile;
                stopAllSounds(); soundHappy.play();
            }
            updatePumkinStyle(pPos.originX, pPos.originY);
            pumkinEl.style.cursor = 'grab';
        }
        if (isMouseDown && !isHappy) { stopAllSounds(); soundUp.play(); }
        isMouseDown = false; isDraggingPumkin = false; lastInteractionTime = Date.now();
    };

    pumkinEl.addEventListener('mousedown', onDown);
    canvas.addEventListener('mousedown', onDown);
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    pumkinEl.addEventListener('touchstart', (e) => { e.preventDefault(); onDown(e); }, {passive: false});
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onDown(e); }, {passive: false});
    window.addEventListener('touchmove', (e) => { onMove(e); }, {passive: false});
    window.addEventListener('touchend', onUp);

    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const now = Date.now();
        if (now - lastInteractionTime > 5500 && !isMouseDown && !isDraggingPumkin) {
            stopAllSounds(); soundIdle.play();
            if (isHappy) { isHappy = false; currentSpeakyImg = imgCache.crying; }
            canvas.classList.add('shake-canvas');
            shakeTimer = setTimeout(() => { canvas.classList.remove('shake-canvas'); shakeTimer = null; }, 2000);
            lastInteractionTime = now;
        }

        const radius = 220; const spring = 0.1; const friction = 0.45;
        for (let i = 0; i < mesh.length; i++) {
            const p = mesh[i]; const orig = originalMesh[i];
            if (isMouseDown && !isHappy) {
                const dx = p.x - targetX; const dy = p.y - fixedY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < radius) {
                    const force = (radius - dist) / radius;
                    p.vy += force * 0.7 * 20; p.vx += (dx / dist) * force * 5;
                }
            }
            const ax = (orig.x - p.x) * spring; const ay = (orig.y - p.y) * spring;
            p.vx = (p.vx + ax) * friction; p.vy = (p.vy + ay) * friction;
            p.x += p.vx; p.y += p.vy;
        }
        render();
        requestAnimationFrame(animate);
    }

    function render() {
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                drawTriangle(x, y, false); drawTriangle(x, y, true);
            }
        }
    }

    function drawTriangle(x, y, reverse) {
        const i1 = y * (cols + 1) + x; const i2 = i1 + 1; const i3 = (y + 1) * (cols + 1) + x; const i4 = i3 + 1;
        let p1, p2, p3, o1, o2, o3;
        if (!reverse) { p1 = mesh[i1]; p2 = mesh[i2]; p3 = mesh[i3]; o1 = originalMesh[i1]; o2 = originalMesh[i2]; o3 = originalMesh[i3]; }
        else { p1 = mesh[i2]; p2 = mesh[i4]; p3 = mesh[i3]; o1 = originalMesh[i2]; o2 = originalMesh[i4]; o3 = originalMesh[i3]; }
        ctx.save(); ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x + 7.5, p2.y + 7.5); ctx.lineTo(p3.x + 7.5, p3.y + 7.5); ctx.closePath(); ctx.clip();
        const dnm = o1.x * (o2.y - o3.y) - o1.y * (o2.x - o3.x) + (o2.x * o3.y - o2.y * o3.x);
        if (Math.abs(dnm) < 0.1) { ctx.restore(); return; }
        const a = (p1.x * (o2.y - o3.y) - o1.y * (p2.x - p3.x) + (p2.x * o3.y - o2.y * p3.x)) / dnm;
        const b = (o1.x * (p2.x - p3.x) - p1.x * (o2.x - o3.x) + (o2.x * p3.x - p2.x * o3.x)) / dnm;
        const c = (o1.x * (o2.y * p3.x - p2.x * o3.y) - o1.y * (o2.x * p3.x - p2.x * o3.x) + p1.x * (o2.x * o3.y - o2.y * o3.x)) / dnm;
        const d = (p1.y * (o2.y - o3.y) - o1.y * (p2.y - p3.y) + (p2.y * o3.y - o2.y * p3.y)) / dnm;
        const e = (o1.x * (p2.y - p3.y) - p1.y * (o2.x - o3.x) + (o2.x * p3.y - p2.y * o3.x)) / dnm;
        const f = (o1.x * (o2.y * p3.y - p2.y * o3.y) - o1.y * (o2.x * p3.y - p2.y * o3.x) + p1.y * (o2.x * o3.y - o2.y * o3.x)) / dnm;
        ctx.setTransform(a, d, b, e, c, f); ctx.drawImage(currentSpeakyImg, 0, 0); ctx.restore();
    }
</script>
</body>
</html>
